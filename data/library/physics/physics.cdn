require "spatial.cdn"
require "inertia.cdn"
require "quaternion.cdn"
require "transformations.cdn"

## Gravity vector
g = "[0; 0; -9.81]"

templates
{
    node "physics"
    {
        node "system"
        {
            m = 0
        }

        ## Basic degree of freedom node having @1 degrees of freedom. This
        ## node only defines variables for position, velocity and
        ## acceleration and the number of degree of freedoms
        node "dof{1:6}"
        {
            null = "zeros(@@1, 1)"

            defines
            {
                names = "{coordinates,velocities,accelerations}"
            }

            ## Generalized @names[@@0[!]] (i.e. DOFs of joint)
            "{q,dq,ddq}" = "null"

            ## Generalized coordinate accelerations differential equation
            q̈ = "ddq"
        }

        ## Base physical body. It represents a single degree of freedom by
        ## default, but it can represent up to 6 degrees of freedom if
        ## a "dofN" template is explicitly applied (see for example
        ## spherical body).
        node "body" : "dof1"
        {
            ## Mass of the body
            m   = "1"

            ## Center of Mass of the body: 3-by-1
            com = "zeros(3, 1)"

            ## Inertia matrix of the body: 3-by-3
            I   = "Inertia.Sphere(m, 0.1)"

            ## Generalized force on the DOF of this body
            τ = "null"

            ## Joint model parameters. These parameters need to be specified
            ## for each joint type.
            node "joint"
            {
                ## Spatial joint transformation (i.e. the transformation induced
                ## by the DOF of the joint).
                JointTransform(q) = "eye(6)"

                ## Velocity across the joint in successor frame coordinates.
                JointVelocity(q, dq) = "zeros(6, 1)"

                ## The joint motion subspace. This is a matrix specifying the
                ## motion subspace of the joint. The motion subspace is defined
                ## by the partial derivative of the joint velocity towards the
                ## the generalized velocities.
                ##
                ## S = ∂v_j / ∂q̇
                MotionSubspace(q, dq) = "∂[JointVelocity; dq](q, dq)"

                ## The constraint force subspace. This only need to be defined
                ## when using kinematic loops or when calculating joint
                ## constraint forces. The constraint force subspace is the
                ## dual of the motion subspace S. It spans the 6 - N degrees
                ## of freedom that are subject to constraints.
                ## Tᵀ ∙ v_j = 0
                ConstraintForceSubspace(q, dq) = "eye(6)"

                ## Joint bias velocity product term. This term is non zero
                ## when the motion subspace is not a constant (i.e. depends on
                ## q).
                ##
                ## c_j = ∂S / ∂q ∙ q̇ᵀ ∙ q̇
                BiasVelocityProduct(q, dq) = "∂[MotionSubspace; q](q, dq) ∙ dqᵀ ∙ dq"
            }

            ## Helper variable to calculate the joint transform
            jointTransform = "joint.JointTransform(q)"

            ## Helper variable to calculate the joint velocity
            jointVelocity = "joint.JointVelocity(q, dq)"

            ## Helper variable to calculate the joint motion subspace
            motionSubspace = "joint.MotionSubspace(q, dq)"

            ## Helper variable to calculate the velocity product term. See
            ## joint.cJ
            cJ = "joint.BiasVelocityProduct(q, dq)"

            ## Transposed motion subspace
            motionSubspaceT = "motionSubspaceᵀ"

            ## Transposed transformation
            transformT = "transformᵀ"

            ## Coordinate transform from the parent frame to the body
            ## frame (i.e. the transformation from the origin of the joint of
            ## the parent to the origin of the joint of the body frame)
            coordinateTransform = "eye(6)"

            ## The total transform from body frame to parent frame, including
            ## both the transform of the coordinate system and the transform
            ## that the joint induces (i.e. through it's generalized
            ## coordinates).
            transform = "jointTransform ∙ coordinateTransform"

            ## Spatial inertia calculated from the mass (m),
            ## center of mass (com) and inertia (I).
            spI = "Spatial.Inertia(com, m, I)"

            ## Body velocity, defaults to joint velocity.
            velocity = "jointVelocity"

            ## Body acceleration due to gravitational and coriolos effects,
            ## defaults to gravity.
            acceleration = "transform ∙ [0; 0; 0; -g] + cJ"

            ## Transform from the local coordinate system to base coordinate
            ## system
            baseToLocalTransform = "transform"
            localToBaseTransform = "Spatial.Inverse(baseToLocalTransform)"

            BaseForceToLocal(f, p) = "Spatial.ForceTransform(baseToLocalTransform) *
                                      Spatial.TranslateForce(f, p)"

            LocalPointToBase(p) = "Spatial.TransformPoint3(localToBaseTransform, p)"
        }

        ## The joint edge connects two bodies in a kinematic chain.
        edge "joint"
        {
            ## Set the base transform of the parent to the parent transform
            ## multiplied by the child base transform. This chains all the
            ## transformations recursively so that all the base transforms
            ## are computed.
            baseToLocalTransform <= "output.transform ∙ baseToLocalTransform"
        }
    }
}

require "joints.cdn"
require "sensors.cdn"

# vi:ex:ts=4:et
