node "Spatial"
{
    ## Spatial inertia
    Inertia_(com, m, I, C) = "[
        I + m ∙ C ∙ Cᵀ, m ∙ C;
        m ∙ Cᵀ, [m, 0, 0; 0, m, 0; 0, 0, m]
    ]"

    Inertia(com, m, I) = "Inertia_(com, m, I, Tilde(com))"

    Tilde(v) = "[
         0,    -v[2],  v[1];
         v[2],  0,    -v[0];
        -v[1],  v[0],  0
    ]"

    ## Create a spatial transform from a 3d translation
    Translate(v) = "[
         1,    0,     0,    0, 0, 0;
         0,    1,     0,    0, 0, 0;
         0,    0,     1,    0, 0, 0;
         0,    v[2], -v[1], 1, 0, 0;
        -v[2], 0,     v[0], 0, 1, 0;
         v[1], -v[0],  0,    0, 0, 1
    ]"

    RotateX_(cθ, sθ) = "[
        1,  0,  0,  0,   0, 0;
        0,  cθ, sθ, 0,   0, 0;
        0, -sθ, cθ, 0,   0, 0;
        0,  0,  0,  1,   0, 0;
        0,  0,  0,  0,  cθ, sθ;
        0,  0,  0,  0, -sθ, cθ
    ]"

    ## Create a spatial transform from a rotation of θ on the X axis
    RotateX(θ) = "RotateX_(cos(θ), sin(θ))"

    RotateZ_(cθ, sθ) = "[
         cθ,  sθ, 0,  0,  0,  0;
        -sθ,  cθ, 0,  0,  0,  0;
         0,   0,  1,  0,  0,  0;
         0,   0,  0,  cθ, sθ, 0;
         0,   0,  0, -sθ, cθ, 0;
         0,   0,  0,   0, 0,  1
    ]"

    ## Create a spatial transform from a rotation of θ on the Z axis
    RotateZ(θ) = "RotateZ_(cos(θ), sin(θ))"

    RotateY_(cθ, sθ) = "[
        cθ, 0, -sθ, 0,  0,  0;
        0,  1,  0,  0,  0,  0;
        sθ, 0,  cθ, 0,  0,  0;
        0,  0,  0,  cθ, 0, -sθ;
        0,  0,  0,  0,  1,  0;
        0,  0,  0,  sθ, 0,  cθ
    ]"

    ## Create a spatial transform from a rotation of θ on the Y axis
    RotateY(θ) = "RotateY_(cos(θ), sin(θ))"

    ## Create a spatial transform from a 3d rotation
    Rotate(R) = "[
        R[0, 0], R[0, 1], R[0, 2], 0,       0,       0;
        R[1, 0], R[1, 1], R[1, 2], 0,       0,       0;
        R[2, 0], R[2, 1], R[2, 2], 0,       0,       0;
        0,       0,       0,       R[0, 0], R[0, 1], R[0, 2];
        0,       0,       0,       R[1, 0], R[1, 1], R[1, 2];
        0,       0,       0,       R[2, 0], R[2, 1], R[2, 2]
    ]"

    FromAxisAngle_(axis, cθ, sθ) = "Spatial.Rotate(
        [cθ + axis[0]² ∙ (1 - cθ),
        axis[0] ∙ axis[1] ∙ (1 - cθ) - axis[2] ∙ sθ,
        axis[0] ∙ axis[2] ∙ (1 - cθ) + axis[1] ∙ sθ;
        axis[1] ∙ axis[0] ∙ (1 - cθ) + axis[2] ∙ sθ,
        cθ + axis[1]² ∙ (1 - cθ),
        axis[1] ∙ axis[2] ∙ (1 - cθ) - axis[0] ∙ sθ;
        axis[2] ∙ axis[0] ∙ (1 - cθ) - axis[1] ∙ sθ,
        axis[2] ∙ axis[1] ∙ (1 - cθ) + axis[0] ∙ sθ,
        cθ + axis[2]² ∙ (1 - cθ)
    ])"

    FromAxisAngle(axis, θ) = "FromAxisAngle_(axis, cos(θ), sin(θ))"

    Quaternion(q) = "Spatial.Rotate(2 ∙ [
        0.5 - q[2]^2 - q[3]^2,	   q[1] ∙ q[2] + q[3] ∙ q[0], q[1] ∙ q[3] - q[2] ∙ q[0];
        q[1] ∙ q[2] - q[3] ∙ q[0], 0.5 - q[1]^2 - q[3]^2,	  q[2] ∙ q[3] + q[1] ∙ q[0];
        q[1] ∙ q[3] + q[2] ∙ q[0], q[2] ∙ q[3] - q[1] ∙ q[0], 0.5 - q[1]^2 - q[2]^2
    ])"

    ## Create a spatial transform from a 3d rotation and translation
    Transform(R, p) = "[
         R[0, 0], R[0, 1],  R[0, 2], 0,       0,       0;
         R[1, 0], R[1, 1],  R[1, 2], 0,       0,       0;
         R[2, 0], R[2, 1],  R[2, 2], 0,       0,       0;
         0,       p[2],    -p[1],    R[0, 0], R[0, 1], R[0, 2];
        -p[2],    0,        p[0],    R[1, 0], R[1, 1], R[1, 2];
         p[1],   -p[0],     0,       R[2, 0], R[2, 1], R[2, 2]
    ]"

    ## Obtain a 3d position from a spatial transform.
    Translation3(sp) = "[
        sp[5, 1];
        sp[3, 2];
        sp[4, 0]
    ]"

    ## Obtain a 3d rotation from a spatial transform. Note that this is simply
    ## the upper 3x3 block of the transform.
    Rotation3(sp) = "[
        sp[0, 0], sp[0, 1], sp[0, 2];
        sp[1, 0], sp[1, 1], sp[1, 2];
        sp[2, 0], sp[2, 1], sp[2, 2]
    ]"

    ## Obtain a 4x4 homogeneous transformation matrix from a spatial
    ## transformation
    Transform4x4(sp) = "[
        sp[0, 0], sp[0, 1], sp[0, 2], sp[5, 1];
        sp[1, 0], sp[1, 1], sp[1, 2], sp[3, 2];
        sp[2, 0], sp[2, 1], sp[2, 2], sp[4, 0];
        0, 0, 0, 1
    ]"

    ## Create a spatial transform containing the rotation part of the provided
    ## spatial transform
    RotationPart(v) = "[
        v[0, 0], v[0, 1], v[0, 2], 0,       0,       0;
        v[1, 0], v[1, 1], v[1, 2], 0,       0,       0;
        v[2, 0], v[2, 1], v[2, 2], 0,       0,       0;
        0,       0,       0,       v[3, 3], v[3, 4], v[3, 5];
        0,       0,       0,       v[4, 3], v[4, 4], v[4, 5];
        0,       0,       0,       v[5, 3], v[5, 4], v[5, 5]
    ]"

    ## Create a spatial transform containing the translation part of the provided
    ## spatial transform
    TranslationPart(v) = "[
         1,       0,       0,       0, 0, 0;
         0,       1,       0,       0, 0, 0;
         0,       0,       1,       0, 0, 0;
         v[3, 0], v[3, 1], v[3, 2], 1, 0, 0;
         v[4, 0], v[4, 1], v[4, 2], 0, 1, 0;
         v[5, 0], v[5, 1], v[5, 2], 0, 0, 1
    ]"

    ## Spatial motion cross product
    CrossMotion(v) = "[
         0,    -v[2],  v[1],  0,     0,     0;
         v[2],  0,    -v[0],  0,     0,     0;
        -v[1],  v[0],  0,     0,     0,     0;
         0,    -v[5],  v[4],  0,    -v[2],  v[1];
         v[5],  0,    -v[3],  v[2],  0,    -v[0];
        -v[4],  v[3],  0,    -v[1],  v[0],  0
    ]"

    ## Spatial force cross product (-CrossMotion(v)ᵀ)
    CrossForce(v) = "[
         0,    -v[2],  v[1], 0,    -v[5],  v[4];
         v[2],  0,    -v[0], v[5],  0,    -v[3];
        -v[1],  v[0],  0,   -v[4],  v[3],  0;
         0,     0,     0,    0,    -v[2],  v[1];
         0,     0,     0,    v[2],  0,    -v[0];
         0,     0,     0,   -v[1],  v[0],  0
    ]"

    # Spatial inverse. The spatial inverse can be computed by transposing
    # each 3x3 block matrix in the spatial 6x6 matrix since each block
    # represents an orthogonal space
    Inverse(v) = "[
        v[0, 0], v[1, 0], v[2, 0], v[0, 3], v[1, 3], v[2, 3];
        v[0, 1], v[1, 1], v[2, 1], v[0, 4], v[1, 4], v[2, 4];
        v[0, 2], v[1, 2], v[2, 2], v[0, 5], v[1, 5], v[2, 5];
        v[3, 0], v[4, 0], v[5, 0], v[3, 3], v[4, 3], v[5, 3];
        v[3, 1], v[4, 1], v[5, 1], v[3, 4], v[4, 4], v[5, 4];
        v[3, 2], v[4, 2], v[5, 2], v[3, 5], v[4, 5], v[5, 5]
    ]"
}

# vi:ex:ts=4:et
