node "Sp"
{
    ## Spatial inertia
    Inertia(com, m, I) = "[
        I + m ∙ C ∙ Cᵀ, m ∙ C;
        m ∙ Cᵀ, [m, 0, 0; 0, m, 0; 0, 0, m]
    ]"
    {
        C = "Tilde(com)"
    }

    Tilde(v) = "[
        0, -v[2], v[1];
        v[2], 0, -v[0];
        -v[1], v[0], 0
    ]"

    ## Create a spatial transform from a 3d translation
    Translate(v) = "[
         1,    0,     0,    0, 0, 0;
         0,    1,     0,    0, 0, 0;
         0,    0,     1,    0, 0, 0;
         0,    v[2], -v[1], 1, 0, 0;
        -v[2], 0,     v[0], 0, 1, 0;
         v[1], v[0],  0,    0, 0, 1
    ]"

    ## Create a spatial transform from a rotation of θ on the X axis
    RotateX(θ) = "[
        1,  0,  0,  0,   0, 0;
        0,  cθ, sθ, 0,   0, 0;
        0, -sθ, cθ, 0,   0, 0;
        0,  0,  0,  1,   0, 0;
        0,  0,  0,  0,  cθ, sθ;
        0,  0,  0,  0, -sθ, cθ
    ]"
    {
        cθ = "cos(θ)"
        sθ = "sin(θ)"
    }

    ## Create a spatial transform from a rotation of θ on the Z axis
    RotateZ(θ) = "[
         cθ,  sθ, 0,  0,  0,  0;
        -sθ,  cθ, 0,  0,  0,  0;
         0,   0,  1,  0,  0,  0;
         0,   0,  0,  cθ, sθ, 0;
         0,   0,  0, -sθ, cθ, 0;
         0,   0,  0,   0, 0,  1
    ]"
    {
        cθ = "cos(θ)"
        sθ = "sin(θ)"
    }

    ## Create a spatial transform from a rotation of θ on the Y axis
    RotateY(θ) = "[
        cθ, 0, -sθ, 0,  0,  0;
        0,  1,  0,  0,  0,  0;
        sθ, 0,  cθ, 0,  0,  0;
        0,  0,  0,  cθ, 0, -sθ;
        0,  0,  0,  0,  1,  0;
        0,  0,  0,  sθ, 0,  cθ
    ]"
    {
        cθ = "cos(θ)"
        sθ = "sin(θ)"
    }

    ## Create a spatial transform from a 3d rotation
    Rotate(R) = "[
        R[0, 0], R[0, 1], R[0, 2], 0,       0,       0;
        R[1, 0], R[1, 1], R[1, 2], 0,       0,       0;
        R[2, 0], R[2, 1], R[2, 2], 0,       0,       0;
        0,       0,       0,       R[0, 0], R[0, 1], R[0, 2];
        0,       0,       0,       R[1, 0], R[1, 1], R[1, 2];
        0,       0,       0,       R[2, 0], R[2, 1], R[2, 2]
    ]"

    ## Create a spatial transform from a 3d rotation and translation
    Transform(R, p) = "[
         R[0, 0], R[0, 1],  R[0, 2], 0,       0,       0;
         R[1, 0], R[1, 1],  R[1, 2], 0,       0,       0;
         R[2, 0], R[2, 1],  R[2, 2], 0,       0,       0;
         0,       p[2],    -p[1],    R[0, 0], R[0, 1], R[0, 2];
        -p[2],    0,        p[0],    R[1, 0], R[1, 1], R[1, 2];
         p[1],    p[0],     0,       R[2, 0], R[2, 1], R[2, 2]
    ]"

    ## Obtain a 3d position from a spatial transform.
    Translation3(sp) = "[
        sp[4, 2];
        sp[5, 0];
        sp[3, 1]
    ]"

    ## Obtain a 3d rotation from a spatial transform. Note that this is simply
    ## the upper 3x3 block of the transform.
    Rotatation3(sp) = "block(sp, [1 2 3], [1 2 3])"

    ## Obtain a 4x4 homogeneous transformation matrix from a spatial
    ## transformation
    Transform4x4(sp) = "[
        sp[0, 0], sp[0, 1], sp[0, 2], sp[4, 2];
        sp[1, 0], sp[1, 1], sp[1, 2], sp[5, 0];
        sp[2, 0], sp[2, 1], sp[2, 2], sp[3, 1];
        0, 0, 0, 1
    ]"

    ## Create a spatial transform containing the rotation part of the provided
    ## spatial transform
    RotationPart(v) = "[
        v[0, 0], v[0, 1], v[0, 2], 0,       0,       0;
        v[1, 0], v[1, 1], v[1, 2], 0,       0,       0;
        v[2, 0], v[2, 1], v[2, 2], 0,       0,       0;
        0,       0,       0,       v[3, 3], v[3, 4], v[3, 5];
        0,       0,       0,       v[4, 3], v[4, 4], v[4, 5];
        0,       0,       0,       v[5, 3], v[5, 4], v[5, 5];
    ]"

    ## Create a spatial transform containing the translation part of the provided
    ## spatial transform
    TranslationPart(v) = "[
         1,       0,       0,       0, 0, 0;
         0,       1,       0,       0, 0, 0;
         0,       0,       1,       0, 0, 0;
         v[3, 0], v[3, 1], v[3, 2], 1, 0, 0;
         v[4, 0], v[4, 1], v[4, 2], 0, 1, 0;
         v[5, 0], v[5, 1], v[5, 2], 0, 0, 1
    ]"

    ## Spatial motion cross product
    CrossMotion(v) = "[
         0,    -v[2],  v[1],  0,     0,     0;
         v[2],  0,    -v[0],  0,     0,     0;
        -v[1],  v[0],  0,     0,     0,     0;
         0,    -v[5],  v[4],  0,    -v[2],  v[1];
         v[5],  0,    -v[3],  v[2],  0,    -v[0];
        -v[4],  v[3],  0,    -v[1],  v[0],  0
    ]"

    ## Spatial force cross product (-CrossMotion(v)ᵀ)
    CrossForce(v) = "[
         0,    -v[2],  v[1], 0,    -v[5],  v[4];
         v[2],  0,    -v[0], v[5],  0,    -v[3];
        -v[1],  v[0],  0,   -v[4],  v[3],  0;
         0,     0,     0,    0,    -v[2],  v[1];
         0,     0,     0,    v[2],  0,    -v[0];
         0,     0,     0,   -v[1],  v[0],  0
    ]"

    # Spatial inverse. The spatial inverse can be computed by transposing
    # each 3x3 block matrix in the spatial 6x6 matrix since each block
    # represents an orthogonal space
    Inverse(v) = "[
        v[0, 0], v[1, 0], v[2, 0], v[0, 3], v[1, 3], v[2, 3];
        v[0, 1], v[1, 1], v[2, 1], v[0, 4], v[1, 4], v[2, 4];
        v[0, 2], v[1, 2], v[2, 2], v[0, 5], v[1, 5], v[2, 5];
        v[3, 0], v[4, 0], v[5, 0], v[3, 3], v[4, 3], v[5, 3];
        v[3, 1], v[4, 1], v[5, 1], v[3, 4], v[4, 4], v[5, 4];
        v[3, 2], v[4, 2], v[5, 2], v[3, 5], v[4, 5], v[5, 5]
    ]"
}

# vi:ex:ts=4:et
